<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Relation Diagrammer</title>
<style>
  :root{
    --bg:#eef4ff;
    --panel:#ffffff;
    --frame:#9aa3ab;
    --chip:#c7f1d3;
    --ink:#0b1f3b;
    --muted:#5b7fa3;

    /* Colores base */
    --accent:#9b5cf4;   /* púrpura por defecto */
    --danger:#e11d48;   /* rojo para errores */

    /* Tamaños por defecto pedidos */
    --num-size:60px;
    --op-size:60px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font:16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    display:grid;
    grid-template-rows:auto 1fr;
  }
  header{
    padding:16px clamp(16px, 4vw, 32px);
    background:linear-gradient(180deg, #f6f9ff 0, transparent 100%);
    display:grid; gap:12px;
  }
  .controls{display:flex; gap:12px; flex-wrap:wrap; align-items:center;}
  textarea{
    width:min(900px, 100%);
    min-height:64px;
    padding:12px 14px;
    border:1px solid #d6e6ff; border-radius:12px;
    background:#fff; color:var(--ink);
    font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    resize:vertical;
  }
  button{
    padding:10px 14px; border-radius:12px; border:0;
    background:#111827; color:#fff; font-weight:600; cursor:pointer;
  }
  .hint{ color:var(--muted); font-size:13px }
  
  .divider{
    border:0;
    border-top:2px solid #cbd5e1;
    margin:16px 0;
  }
  .sliders{display:flex; flex-wrap:wrap; gap:18px; align-items:center;}
  .sliderGroup{display:flex; align-items:center; gap:6px;}
  .sliderGroup input[type="number"]{
    width:64px;
    padding:3px 6px;
    border:1px solid #ccc;
    border-radius:6px;
    font-size:14px;
  }
  .actions{display:flex; gap:10px; flex-wrap:wrap; align-items:center}

  .grid{
    padding:20px clamp(16px, 4vw, 32px) 40px;
    display:grid;
    grid-template-columns:repeat(auto-fill, minmax(340px, 1fr));
    gap:18px;
    align-content:start;
  }

  .card{ border-radius:22px; background:var(--frame); padding:12px; }
  .panel{ border-radius:14px; background:var(--panel); padding:14px; }

  .chip{ fill:var(--chip); stroke:#a2e3b5; stroke-width:1; }
  .chipText{
    font-weight:800;
    font-size:var(--num-size);
    dominant-baseline:middle;
    text-anchor:middle;
  }
  /* El operador y la línea reciben color inline en el render */
  .opText{
    fill:#fff;
    font-weight:900;
    font-size:var(--op-size);
    dominant-baseline:middle;
    text-anchor:middle;
  }

  .error{
    color:#b91c1c; background:#fee2e2; border:1px solid #fecaca;
    padding:8px 10px; border-radius:10px; font-size:14px; display:none;
  }

  .toggle{
    display:inline-flex; align-items:center; gap:8px;
    padding:8px 10px; background:#fff; border:1px solid #e5e7eb; border-radius:10px;
  }
</style>
</head>
<body>

<header>
  <h1>Relation Diagrammer</h1>

  <div class="controls">
    <textarea id="input" spellcheck="false">10=10 , 10 > 5, 5 < 10, 6=6</textarea>
    <div class="actions">
      <button id="renderBtn">Render</button>
      <button id="downloadPng">Descargar PNG (2 columnas)</button>
      <label class="toggle" title="Colorea en rojo las relaciones falsas">
        <input type="checkbox" id="toggleWrong">
        Resaltar relaciones incorrectas
      </label>
    </div>
  </div>

  <div class="sliders">
    <label class="sliderGroup">Números:
      <input type="range" id="numSize" min="12" max="60" value="60">
      <input type="number" id="numSizeBox" min="12" max="60" value="60">
    </label>
    <label class="sliderGroup">Símbolo:
      <input type="range" id="opSize" min="12" max="60" value="60">
      <input type="number" id="opSizeBox" min="12" max="60" value="60">
    </label>
    <label class="sliderGroup">Cuadrados verdes:
      <input type="range" id="chipSize" min="60" max="180" value="125">
      <input type="number" id="chipSizeBox" min="60" max="180" value="125">
    </label>
    <label class="sliderGroup">Rectángulo morado:
      <input type="range" id="badgeScale" min="60" max="240" value="200">
      <input type="number" id="badgeScaleBox" min="60" max="240" value="200">
      <span class="hint">%</span>
    </label>
    <label class="sliderGroup">Largo línea:
      <input type="range" id="lineLen" min="40" max="260" value="260">
      <input type="number" id="lineLenBox" min="40" max="260" value="260">
      <span class="hint">px</span>
    </label>
  </div>

  <div class="hint">Formato: izquierda operador derecha. Operadores: =, &gt;, &lt;. Separa relaciones con comas.</div>
  <div id="err" class="error"></div>
</header>

<hr class="divider">

<main class="grid" id="grid" aria-live="polite"></main>

<script>
/* ---------- Parser & truth check ---------- */
function parseRelation(token){
  const t = token.trim();
  if(!t) return null;
  const m = t.match(/^(.+?)(=|>|<)(.+)$/);
  if(!m) return null;
  return { left:m[1].trim(), op:m[2].trim(), right:m[3].trim() };
}
function isNumeric(x){
  const v = Number(x);
  return Number.isFinite(v) ? v : null;
}
/* ---------- Evaluador numérico con expresiones ---------- */
function evalExpression(expr) {
  try {
    // Solo permitir números, + - * / y paréntesis
    if (!/^[\d+\-*/()\s.]+$/.test(expr)) return null;
    // Usamos Function para evaluar de manera segura
    const val = Function('"use strict"; return (' + expr + ')')();
    return Number.isFinite(val) ? val : null;
  } catch {
    return null;
  }
}

function relationIsTrue(rel){
  const a = evalExpression(rel.left);
  const b = evalExpression(rel.right);
  if (a===null || b===null) return null;    // no evaluable => no marcar
  if (rel.op === '=') return a === b;
  if (rel.op === '>') return a > b;
  if (rel.op === '<') return a < b;
  return null;
}

/* ---------- Diagram builder ---------- */
function buildDiagram(rel, opts){
  const { chipW, chipH, badgeScale, span, highlightWrong } = opts;
  const W = 500, H = 120, midY = H/2, chipRX=14;
  const leftCenterX  = (W - span)/2;
  const rightCenterX = (W + span)/2;

  // Color según toggle
  let color = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#9b5cf4';
  const truth = relationIsTrue(rel);
  if (highlightWrong && truth === false) {
    color = getComputedStyle(document.documentElement).getPropertyValue('--danger').trim() || '#e11d48';
  }

  const svgNS='http://www.w3.org/2000/svg';
  const card=document.createElement('div'); card.className='card';
  const panel=document.createElement('div'); panel.className='panel'; card.appendChild(panel);
  const svg=document.createElementNS(svgNS,'svg');
  svg.setAttribute('viewBox',`0 0 ${W} ${H}`); svg.setAttribute('width','100%'); svg.setAttribute('height','120');
  panel.appendChild(svg);

  // Línea
  const line=document.createElementNS(svgNS,'line');
  line.setAttribute('x1',leftCenterX); line.setAttribute('y1',midY);
  line.setAttribute('x2',rightCenterX); line.setAttribute('y2',midY);
  line.setAttribute('stroke', color); line.setAttribute('stroke-width','10'); line.setAttribute('stroke-linecap','round');
  svg.appendChild(line);

  // Badge operador
  const badgeW=44*(badgeScale/100), badgeH=26*(badgeScale/100);
  const badge=document.createElementNS(svgNS,'rect');
  badge.setAttribute('x',(W-badgeW)/2); badge.setAttribute('y',(H-badgeH)/2);
  badge.setAttribute('width',badgeW); badge.setAttribute('height',badgeH);
  badge.setAttribute('rx',10); badge.setAttribute('fill', color);
  svg.appendChild(badge);

  const opText=document.createElementNS(svgNS,'text');
  opText.setAttribute('x',W/2); opText.setAttribute('y',H/2+1);
  opText.setAttribute('class','opText'); opText.textContent=rel.op;
  svg.appendChild(opText);

  // Chips verdes
  const leftRect=document.createElementNS(svgNS,'rect');
  leftRect.setAttribute('x',leftCenterX-chipW/2); leftRect.setAttribute('y',midY-chipH/2);
  leftRect.setAttribute('width',chipW); leftRect.setAttribute('height',chipH);
  leftRect.setAttribute('rx',chipRX); leftRect.setAttribute('class','chip'); svg.appendChild(leftRect);

  const leftLabel=document.createElementNS(svgNS,'text');
  leftLabel.setAttribute('x',leftCenterX); leftLabel.setAttribute('y',midY+2);
  leftLabel.setAttribute('class','chipText'); leftLabel.textContent=rel.left; svg.appendChild(leftLabel);

  const rightRect=document.createElementNS(svgNS,'rect');
  rightRect.setAttribute('x',rightCenterX-chipW/2); rightRect.setAttribute('y',midY-chipH/2);
  rightRect.setAttribute('width',chipW); rightRect.setAttribute('height',chipH);
  rightRect.setAttribute('rx',chipRX); rightRect.setAttribute('class','chip'); svg.appendChild(rightRect);

  const rightLabel=document.createElementNS(svgNS,'text');
  rightLabel.setAttribute('x',rightCenterX); rightLabel.setAttribute('y',midY+2);
  rightLabel.setAttribute('class','chipText'); rightLabel.textContent=rel.right; svg.appendChild(rightLabel);

  return card;
}

/* ---------- State, sliders & render ---------- */
const inputEl=document.getElementById('input');
const gridEl=document.getElementById('grid');
const errEl=document.getElementById('err');
const highlightBox=document.getElementById('toggleWrong');

const numSlider=document.getElementById('numSize');
const numBox=document.getElementById('numSizeBox');
const opSlider=document.getElementById('opSize');
const opBox=document.getElementById('opSizeBox');
const chipSlider=document.getElementById('chipSize');
const chipBox=document.getElementById('chipSizeBox');
const badgeSlider=document.getElementById('badgeScale');
const badgeBox=document.getElementById('badgeScaleBox');
const lineSlider=document.getElementById('lineLen');
const lineBox=document.getElementById('lineLenBox');

function computeOptions(){
  const chipW=+chipSlider.value, chipH=Math.round(chipW*0.6);
  const badgeScale=+badgeSlider.value;
  const span=+lineSlider.value;
  return {chipW, chipH, badgeScale, span, highlightWrong: highlightBox.checked};
}
function renderAll(){
  errEl.style.display='none'; errEl.textContent='';
  gridEl.innerHTML='';
  const opts=computeOptions();
  const items=inputEl.value.split(',').map(parseRelation).filter(Boolean);
  if(!items.length){ gridEl.innerHTML='<div class="hint">Nada válido.</div>'; return;}
  items.forEach(r=>gridEl.appendChild(buildDiagram(r,opts)));
}
function bindPair(slider, box, cb){
  slider.addEventListener('input', ()=>{ box.value=slider.value; cb(); });
  box.addEventListener('input', ()=>{ slider.value=box.value; cb(); });
}
bindPair(numSlider,numBox, ()=>document.documentElement.style.setProperty('--num-size', numSlider.value+'px'));
bindPair(opSlider,opBox, ()=>document.documentElement.style.setProperty('--op-size', opSlider.value+'px'));
bindPair(chipSlider,chipBox, renderAll);
bindPair(badgeSlider,badgeBox, renderAll);
bindPair(lineSlider,lineBox, renderAll);

document.getElementById('renderBtn').addEventListener('click', renderAll);
inputEl.addEventListener('input', ()=>{clearTimeout(window.t); window.t=setTimeout(renderAll,200);});
highlightBox.addEventListener('change', renderAll);

/* ======== EXPORT: PNG en 2 columnas, conservando estilos ======== */
document.getElementById('downloadPng').removeEventListener?.('click', exportAsPngTwoCols);
document.getElementById('downloadPng').addEventListener('click', exportAsPngTwoCols);

async function exportAsPngTwoCols(){
  // 1) Tomamos todos los SVGs y les incrustamos estilos
  const svgs = Array.from(gridEl.querySelectorAll('svg'));
  if (!svgs.length) return;

  const images = await Promise.all(svgs.map(svg => svgToImage(inlineSvgStyles(svg))));

  // 2) Medidas de cada tarjeta (igual que en la vista)
  const svgW = 500, svgH = 120;   // tamaño del viewBox de cada svg
  const pad = 14 + 10;            // padding interno del panel (14) + pad que usamos al export (10)
  const framePad = 12;            // "grosor" visual del marco gris en la vista
  const frameR = 22, panelR = 14; // radios como en CSS

  const cellW = svgW + pad*2 + framePad*2;
  const cellH = svgH + pad*2 + framePad*2;

  const cols = 2;
  const rows = Math.ceil(images.length / cols);
  const gutterX = 24, gutterY = 24, margin = 20;

  const outW = margin*2 + cols*cellW + (cols-1)*gutterX;
  const outH = margin*2 + rows*cellH + (rows-1)*gutterY;

  const scale = Math.max(2, Math.min(3, Math.ceil(window.devicePixelRatio || 1)));
  const canvas = document.createElement('canvas');
  canvas.width = Math.floor(outW * scale);
  canvas.height = Math.floor(outH * scale);
  const ctx = canvas.getContext('2d');
  ctx.scale(scale, scale);

  // Fondo como la página
  ctx.fillStyle = getCSS('--bg', '#eef4ff');
  ctx.fillRect(0, 0, outW, outH);

  // 3) Pintar tarjetas + svg rasterizado
  const frameColor = getCSS('--frame', '#9aa3ab');
  images.forEach((img, i) => {
    const r = Math.floor(i / cols);
    const c = i % cols;
    const x = margin + c*(cellW + gutterX);
    const y = margin + r*(cellH + gutterY);

    // Marco gris
    drawRoundedRect(ctx, x, y, cellW, cellH, frameR);
    ctx.fillStyle = frameColor; ctx.fill();

    // Panel blanco
    const panelX = x + framePad, panelY = y + framePad;
    const panelW = cellW - framePad*2, panelH = cellH - framePad*2;
    drawRoundedRect(ctx, panelX, panelY, panelW, panelH, panelR);
    ctx.fillStyle = '#ffffff'; ctx.fill();

    // Contenido SVG
    ctx.drawImage(img, panelX + (pad-10), panelY + (pad-10), svgW, svgH);
  });

  // 4) Descargar
  const url = canvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.download = `relaciones.png`;
  a.href = url;
  a.click();
}

/* --- Helpers de dibujo --- */
function drawRoundedRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}
function getCSS(varName, fallback){
  const v = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  return v || fallback;
}

/* --- Incrustar estilos en el SVG (clave para que no salga negro) --- */
function inlineSvgStyles(svg){
  // Clonar para no tocar el DOM visible
  const clone = svg.cloneNode(true);

  // Reglas: copiamos fill, stroke, font-family, font-size, font-weight, stroke-width, etc.
  const props = [
    'fill','stroke','stroke-width','stroke-linecap','stroke-linejoin','opacity',
    'font-family','font-size','font-weight','text-anchor','dominant-baseline'
  ];

  const walker = document.createTreeWalker(clone, NodeFilter.SHOW_ELEMENT, null);
  while (walker.nextNode()) {
    const el = walker.currentNode;
    const cs = getComputedStyle(svg.querySelector(`[data-exp-id="${getOrSetId(el, svg)}"]`) || el);
    // color/es con variables -> computados a rgb(...)
    props.forEach(p => {
      const val = cs.getPropertyValue(p);
      if (val) el.setAttribute(p, val.trim());
    });
  }

  // Asegurar atributos base
  clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  clone.setAttribute('width', '500');
  clone.setAttribute('height', '120');
  clone.setAttribute('viewBox', '0 0 500 120');
  return clone;
}

// Asigna ids temporales pareados entre svg original y clon para leer computedStyle
function getOrSetId(el, refSvg){
  if (!el.__exp_tmpid) {
    el.__exp_tmpid = Math.random().toString(36).slice(2);
    // marcar en original y clon
    const idx = Array.prototype.indexOf.call(el.parentNode?.children || [], el);
  }
  // Para mapear computedStyle, usamos un atributo data-exp-id en el original antes de clonar
  // (si ya existe, lo reutilizamos)
  if (!el.getAttribute?.('data-exp-id')) el.setAttribute?.('data-exp-id', el.__exp_tmpid);
  return el.__exp_tmpid;
}

/* --- Serializar svg a Image() --- */
function svgToImage(svgNode){
  return new Promise((resolve, reject) => {
    const xml = new XMLSerializer().serializeToString(svgNode);
    const src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(xml);
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = src;
  });
}


/* Render inicial */
renderAll();
</script>
</body>
</html>
